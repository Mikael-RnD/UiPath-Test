name: 'UiPath Test'
description: 'Runs test cases within a UiPath project'
inputs:
  projectFilePaths:
    description: 'Used for passing explicit paths to project files to perform analysis. Can be used as multi-line inputs'
    required: false
  orchestratorUrl: 
    description: 'Orchestrator instance URL'
    required: false
    default: "https://cloud.uipath.com/"
  orchestratorTenant:
    description: 'Tenant on the Orchestrator instance'
    required: true
  orchestratorFolder:
    description: 'Folder path in modern folder setup'
    required: true
  orchestratorApplicationId:
    description: 'Account for authenticating to Orchestrator'
    required: true
  orchestratorApplicationSecret:
    description: 'Password for the Orchestrator account'
    required: true
  orchestratorApplicationScope:
    description: 'Access scope for external application'
    required: false
    default: "OR.Assets OR.BackgroundTasks OR.Execution OR.Folders OR.Jobs OR.Machines.Read OR.Monitoring OR.Robots.Read OR.Settings.Read OR.TestSets OR.TestSetExecutions OR.TestSetSchedules OR.Users.Read"
  orchestratorLogicalName:
    description: 'Logical name for Orchestrator organization'
    required: true
outputs:
  testExecutionLinks:
    description: 'Outputs a comma-separated list of Orchestrator links for viewing test results'
    value: ${{ steps.parse_test_results.outputs.testExecutionLinks }}
  testResults:
    description: 'Markdown formatted table listing the tests that have been run and whether they passed or failed'
    value: ${{ steps.parse_test_results.outputs.testResults }}
  containsPublishableTestCases:
    description: 'Boolean value indicating whether any test cases set as publishable were found in the repository'
    value: ${{ steps.run_tests.outputs.containsPublishableTestCases }}

runs:
  using: "composite"
  steps:
    - id: get_folder_id
      name: Get Folder ID
      shell: bash
      run: |
        headers="Content-Type: application/x-www-form-urlencoded"
        orchestratorURL="${{ inputs.orchestratorUrl }}"
        orchestratorURL="${orchestratorURL%/}"

        # URL encode inputs
        clientId=$(echo -n "${{ inputs.orchestratorApplicationId }}" | jq -sRr @uri)
        clientSecret=$(echo -n "${{ inputs.orchestratorApplicationSecret }}" | jq -sRr @uri)
        scope=$(echo -n "${{ inputs.orchestratorApplicationScope }}" | jq -sRr @uri)

        # Prepare body for the token request
        body="grant_type=client_credentials&client_id=$clientId&client_secret=$clientSecret&scope=$scope"
        authResponse=$(curl -s -X POST "$orchestratorURL/identity_/connect/token" -H "${headers[@]}" -d "$body")
        accessToken=$(echo "$authResponse" | jq -r '.access_token')

        if [ -z "$accessToken" ] || [ "$accessToken" == "null" ]; then
          echo "Error: Failed to obtain access token. Response: $authResponse"
          exit 1
        fi

        # Prepare folder request
        folderName="${{ inputs.orchestratorFolder }}"
        parameters="\$filter=FullyQualifiedName eq '$folderName'"
        encodedParameters=$(jq -rn --arg params "$parameters" '$params | @uri')
        echo $encodedParameters

        folderRequestURL="$orchestratorURL/${{ inputs.organizationId }}/${{ inputs.orchestratorTenant }}/orchestrator_/odata/folders?$encodedParameters"
        echo "Requesting folder ID from URL: $folderRequestURL"
        folderRequestHeaders=("Authorization: Bearer $accessToken")
        
        # Make the request and capture both the response and the HTTP status code
        folderRequestResponse=$(curl -s -w "%{http_code}" -o response_body.txt -X GET "$folderRequestURL" -H "${folderRequestHeaders[@]}")
        httpStatus=$(tail -c 3 <<< "$folderRequestResponse")
        responseBody=$(cat response_body.txt)
        echo "GET Folder response: $responseBody"

        # Check if the status code is not 200
        if [ "$httpStatus" -ne 200 ]; then
          echo "Warning: GET folder request failed with status code $httpStatus. Response: $responseBody"
        else
          folderId=$(echo "$responseBody" | jq -r '.value[0].Id')
          echo "folderId=$folderId" >> $GITHUB_OUTPUT
        fi
        

    - id: run_tests
      name: Test
      shell: bash
      run: |
        testsFailed=0
        testResultsFolder="${{ github.workspace }}/test-results"
        echo "testResultsFolder=$testResultsFolder" >> $GITHUB_OUTPUT
        mkdir -p "$testResultsFolder"
        testResults=""
        testExecutionBaseURL="${{ inputs.orchestratorUrl }}${{ inputs.orchestratorLogicalName }}/${{ inputs.orchestratorTenant }}/orchestrator_/test/executions/"
        testExecutionURLs=""
        repositoryContainsTests=0

        if [ -z "${{ inputs.projectFilePaths }}" ]; then
          echo "Scanning full repository directory for project.json files"
          projectJsonFiles=$(find "${{ github.workspace }}" -type f -name "project.json")
        else
          echo "Getting full path for files given as inputs"
          projectJsonFiles=$(echo "${{ inputs.projectFilePaths }}" | tr '\r\n' '\n' | sed '/^\s*$/d' | while read -r line; do echo "${{ github.workspace }}/$line"; done)
        fi

        while IFS= read -r projectFile; do
          projectInfo=$(cat "$projectFile" | jq '.')
          targetFramework=$(echo "$projectInfo" | jq -r '.targetFramework')
          fileInfoCollection=$(echo "$projectInfo" | jq -r '.designOptions.fileInfoCollection')

          if [ "$(echo "$fileInfoCollection" | jq length)" -gt 0 ]; then
            publishableTests=$(echo "$fileInfoCollection" | jq '[.[] | select(.editingStatus == "Publishable")] | length')
            if [ "$publishableTests" -gt 0 ]; then
              repositoryContainsTests=1
              echo "containsPublishableTestCases=true" >> $GITHUB_OUTPUT
              testResultFilePath="$testResultsFolder/$(echo "$projectInfo" | jq -r '.name')-testresults.json"

              echo "Running tests for project $(echo "$projectInfo" | jq -r '.name')"
              uipcli test run "${{ inputs.orchestratorUrl }}" "${{ inputs.orchestratorTenant }}" \
                --project-path "$projectFile" \
                --accountForApp "${{ inputs.orchestratorLogicalName }}" \
                --applicationId "${{ inputs.orchestratorApplicationId }}" \
                --applicationSecret "${{ inputs.orchestratorApplicationSecret }}" \
                --applicationScope "${{ inputs.orchestratorApplicationScope }}" \
                --organizationUnit "${{ inputs.orchestratorFolder }}" \
                --out uipath \
                --result_path "$testResultFilePath" \
                --language en-US

              if [ $? -ne 0 ]; then
                testsFailed=1
              fi
            else
              echo "$(echo "$projectInfo" | jq -r '.name') contains no test cases set as publishable. Testing skipped."
              testResults+="\n- :warning: **$(echo "$projectInfo" | jq -r '.name') contains no test cases set as publishable. Testing skipped.**\n"
            fi
          else
            echo "$(echo "$projectInfo" | jq -r '.name') contains no test cases. Testing skipped."
            testResults+="\n- :warning: **$(echo "$projectInfo" | jq -r '.name') contains no test cases. Testing skipped.**\n"
          fi
        done <<< "$projectJsonFiles"


        # Output that no tests were found
        if [ "$repositoryContainsTests" -eq 0 ]; then
          echo "No publishable UiPath test cases were found in this repository. Testing has been skipped."
          echo "containsPublishableTestCases=false" >> $GITHUB_OUTPUT
        fi

        echo -e "testResults<<EOF\n$testResults\nEOF" >> $GITHUB_OUTPUT

        if [ "$testsFailed" -ne 0 ]; then
          echo "Tests failed"
          exit 1
        fi

    - id: parse_test_results
      name: Parse test results
      if: always()
      shell: bash
      run: |
        testResults="${{ steps.run_tests.outputs.testResults }}"
        testExecutionUrls=""
        testResultsFolder="${{ steps.run_tests.outputs.testResultsFolder }}"
        testExecutionBaseURL="${{ inputs.orchestratorUrl }}${{ inputs.orchestratorLogicalName }}/${{ inputs.orchestratorTenant }}/orchestrator_/test/executions/"
        folderId="${{ steps.get_folder_id.outputs.folderId }}"  

        # Loop through all JSON files in the test results folder
        while IFS= read -r testResultFilePath; do
          echo "Processing test result file: $testResultFilePath"
          testResultData=$(cat "$testResultFilePath" | jq '.')
          testCaseExecutions=$(echo "$testResultData" | jq -c '.TestSetExecutions[] | .TestCaseExecutions')
          testSetExecutionLink="$testExecutionBaseURL$(echo "$testResultData" | jq -r '.TestSetExecutions[0].Id')?fid=$folderId"

          echo "Test execution can be viewed in Orchestrator by clicking this link: $testSetExecutionLink"

          testResultsTable="| Test case | Result |\n| :-- | :-- |"
          while IFS= read -r testCase; do
            testName=$(echo "$testCase" | jq -r '.Name')
            testStatus=$(echo "$testCase" | jq -r '.Status')
            testResultsTable+="\n| $testName | $(if [ "$testStatus" == "Passed" ]; then echo ":white_check_mark: Passed"; else echo ":x: Failed"; fi) |"
          done <<< $(echo "$testCaseExecutions" | jq -c '.[]')

          testResults+="\n### [Test results for $(echo "$testResultData" | jq -r '.TestSetExecutions[0].Name')]($testSetExecutionLink)\n$testResultsTable"

          if [ -z "$testExecutionURLs" ]; then
            testExecutionURLs="$testSetExecutionLink"
          else
            testExecutionURLs+=", $testSetExecutionLink"
          fi
        done < <(find "$testResultsFolder" -type f -name "*.json")

        echo "testExecutionLinks=$testExecutionURLs" >> $GITHUB_OUTPUT
        echo -e "testResults<<EOF\n$testResults\nEOF" >> $GITHUB_OUTPUT
        
        echo -e "$testResults" >> $GITHUB_STEP_SUMMARY

        echo "${{ steps.run_tests.outputs.testExecutionLinks }}"
        echo "${{ steps.run_tests.outputs.testResults }}"
